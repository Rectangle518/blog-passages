临近期末，想写一写对于这学期的几门课的知识点总结，便于更好地复习。
如有错误，还请指出，不胜感激！

# 线性部分


# 非线性部分

## 图

### 图的基本概念

由于图的基本概念比较简单，对于大多数内容，这里不再赘述，只简要列出需要掌握的概念，并着重强调一些易混淆的知识点。

以下是基本概念列表：图的定义（顶点集、边集）、有向图、无向图、简单图和多重图、完全图、子图、连通图和连通分量、强连通图和强连通分量、生成树和生成森林、顶点的度、入度和出度、边的权、网、稠密图和稀疏图、路径和路径长度、简单路径和简单回路、有向树

> Tips1：如果一个图满足：不存在重复边，且顶点之间没有自环，则该图是**简单图**。

> Tips2：如果一个图的任意两个顶点之间都存在边，则该图是**完全图**。无向完全图有n(n-1)/2条边，有向完全图有n(n-1)条边。

> Tips3：强连通是针对**有向**图而言的，若有一对顶点满足：a->b且b->a（**存在路径，不要求直接相连**），则这对顶点是强连通的。若图中任意一对顶点都是强连通的，则该图是**强连通图**。有向图中的极大强连通子图称为该有向图的强连通分量。

> Tips4：若有向图中存在一个顶点的入度为0，且其余顶点的入度均为1，则该图称为**有向树**。

> Tips5：区别极大和极小连通子图。**极大连通子图（连通分量）** 要求子图连通且包含尽可能多的顶点和边；**极小连通子图**要求子图连通且包含尽可能少的边。

<br>

### 图的存储

#### 邻接矩阵
邻接矩阵的存储结构是一个二维数组，行和列的索引分别表示顶点，数组元素表示两个顶点之间是否存在边。
对于有向图，统计**某一行或某一列的元素为1的个数**，即为该顶点的入度或出度。无向图同理，但不区分入度和出度。
稠密图适合用邻接矩阵存储，稀疏图适合用邻接表存储。

#### 邻接表
邻接表存储结构是一个链表数组，数组的索引表示顶点，链表数组的元素是一个链表，链表的元素表示该顶点所连接的顶点。

> Tips1：一个图的邻接矩阵表示唯一，邻接表表示**不唯一**。

> Tips2：有向图的邻接表中，默认链表中的元素是弧尾。

#### 十字链表
十字链表是一种**用于存储有向图**的链式数据结构，它将邻接矩阵的行和列分别存储为两个链表，分别表示顶点的入度和出度。

#### 邻接多重表
邻接多重表是一种**用于存储无向图**的链式数据结构，它将邻接矩阵的行和列分别存储为两个链表。

<br>

### 图的遍历

#### 复杂度分析
遍历算法的复杂度取决于采用的存储结构。
如果采用邻接表存储结构，每个节点需要访问一次，在搜索每个节点的邻接点时，需要遍历该节点的链表，因此时间复杂度为**O(|V|+|E|)**。
如果采用邻接矩阵存储结构，每个节点需要访问一次，在搜索每个节点的邻接点时，需要遍历该行或列，因此时间复杂度为**O(|V|²)**。

#### BFS
唯一需要注意的是，在入队时就将顶点标记为已访问，避免重复入队。而不是等到出队访问时才进行标记。

#### DFS

> Tips1：对同一个图，基于邻接矩阵遍历得到的DFS和BFS序列是唯一的，但邻接表遍历得到的DFS和BFS序列**不唯一**。

<br>

### 图的应用

#### 最小生成树
一个连通图的生成树包含图的所有顶点，并且只包含构成连通图的最少的边。对于一个带权连通无向图G，生成树不同，每棵树的权值也可能不同，权值之和最小的那棵生成树称为G的**最小生成树**。

##### Prim算法
Prim算法是一种贪心算法，用于求解最小生成树。其基本思想是从一个顶点开始，逐步将顶点加入生成树，每次**选择一个与当前生成树距离最近的顶点加入生成树**，直到所有顶点都被加入生成树。

##### Kruskal算法
Kruskal算法也是一种贪心算法，用于求解最小生成树。其基本思想是将所有边按权值从小到大排序，然后**依次选择权值最小的边加入生成树**，但需要判断加入该边后是否会形成环（使用并查集判断该边的两个顶点是否已经连通），如果会形成环，则不加入该边。

#### 最短路径
最短路径是指从一个顶点到另一个顶点的最短路径，对于带权图，最短路径的权值之和最小。对于无权图，最短路径的边数最少。

##### Dijkstra算法
Dijkstra算法是一种贪心算法，用于求解**非负**权图的**单源**最短路径。
> 假设有n个顶点，求解顶点1到其余各个顶点的最短路径。
> 维护3个数组：dist[]表示顶点1到其余顶点的最短路径长度，prev[]表示最短路径的前驱顶点，flag[]表示顶点是否已经确定最短路径（是否已经加入集合S）。
> 1. 初始化：将顶点1加入集合S，表示已经访问过的顶点，其余顶点加入集合U，表示未访问过的顶点。初始化距离数组dist，将顶点1到其余顶点的距离设为无穷大，将顶点1到自身的距离设为0。
> 2. 选择：在集合U中，选择一个dist值最小的顶点v，将其加入集合S，即令flag[v] = true。
> 3. 更新：对于v的每个邻居节点k，若dist[v] + weight(v, k) < dist[k]，则更新**dist[k] = dist[v] + weight(v, k)**，并更新**prev[k] = v**。
> 4. 重复步骤2和步骤3，直到集合U为空。
>
> 堆优化：使用最小堆来维护集合U中的顶点，每次选择dist值最小的顶点，堆操作的时间复杂度为O(log|V|)。

##### Floyd算法
Floyd算法是一种动态规划算法，用于求解**任意两点之间**的最短路径。其基本思想是逐步增加路径的中间顶点，更新最短路径。

> 假设有n个顶点，求解任意两点之间的最短路径。
> 维护一个二维数组dist，dist[i][j]表示顶点i到顶点j的最短路径长度。
> 1. 初始化：将dist数组初始化为邻接矩阵，将dist[i][i]设为0，其余元素设为无穷大。
> 2. 更新：对于每个中间顶点k（k从1遍历到n），更新**dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])**。
> 3. 返回dist数组。
>
> 注意：Floyd算法适用于带负权值的图，但不适用于带负权回路的图。

#### 拓扑排序
拓扑排序是指将一个有向无环图（DAG）中的顶点按照顶点之间的依赖关系排序，使得对于每一条有向边(u, v)，顶点u在顶点v之前出现。
AOV网（Activity On Vertex Network）是一种特殊的**有向无环图**，用于表示工程中的各个活动及其相互关系。AOV网中的顶点表示活动，边表示活动之间的依赖关系。
> 拓扑排序的算法：
> 1. 统计每个顶点的入度，将入度为0的顶点加入队列。
> 2. 从队列中取出一个顶点，将其加入拓扑排序序列，并将其所有邻接点的入度减1，如果某个邻接点的入度减为0，则将其加入队列。
> 3. 重复步骤2，直到队列为空。

#### 关键路径
AOE网（Activity On Edge Network）是一种特殊的**有向无环图**，用于表示工程中的各个活动及其相互关系。AOE网中的顶点表示事件，边表示活动，边的权值表示活动的持续时间。**关键路径**是指从源点到汇点的最长路径，即路径上的活动持续时间之和最大的路径。

