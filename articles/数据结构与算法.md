临近期末，想写一写对于这学期的几门课的知识点总结，便于更好地复习。
这篇文章比较长，建议在PC端食用。
如有错误，还请指出，不胜感激！


## 时间复杂度

这里仅给出一道例题，分析下面代码的时间复杂度。
```cpp
for (int i = 1; i < n; i *= 2) {
    for (int j = 0; j < i; j++) {
        cout << 1 << '\n';
    }
}
```
提示：循环可以这样改写，对 $i$ 和 $n$ 同时对2取对数，令$k=log_2 i$。
```cpp
for (int k = 0; k < log_2(n); k++) {
    for (j = 0; j < pow(2, k); j++) {
        cout << 1 << '\n';
    }
}
```
答案：$O(n)$，不严格地计算一下：
$$
\sum_{k=1}^{\log_2 n}\sum_{j=0}^{2^k-1}1=\sum_{k=1}^{\log_2 n}2^k=2^{\log_2 n+1}-2=2n-2
$$

> 易错点：答案并不是$O(n\log_2 n)$，因为内层循环的次数并不是固定的。

# 线性部分

## 栈

### 栈的基本概念

1. 栈顶是允许插入和删除的一端，栈底是固定的一端。
2. 当n个不同元素入栈时，出栈顺序有$\frac{1}{n+1}C(2n,n)$种，这个公式称为卡特兰数公式，可以用数学归纳法证明。

### 维护栈中的最小元素

维护一个辅助栈，用于存储当前栈中的最小元素。

```cpp
// 入栈时
// 如果辅助栈为空或新元素小于等于辅助栈顶，则压入辅助栈
stack.push(x);
if (min_stack.empty() || x <= min_stack.top()) {
    min_stack.push(x);
}

// 出栈时
// 如果主栈顶等于辅助栈顶，则辅助栈也出栈
if (stack.top() == min_stack.top()) {
    min_stack.pop();
}
stack.pop();

// 获取主栈中的最小元素
// 就是辅助栈的栈顶元素
auto min_element = min_stack.top();
```

### 判断合法的出栈序列
用一个辅助栈模拟入栈与出栈过程：
1. 按顺序将入栈序列（例如 1~n）逐个入栈；
2. 每入一个元素，就检查是否可以与出栈序列的下一个元素匹配；
3. 如果匹配，就执行出栈操作，继续循环检查；
4. 最后如果辅助栈为空且所有出栈序列都匹配成功 -> 合法
```cpp
bool isValidPopOrder(const vector<int>& pushSeq, const vector<int>& popSeq) {
    stack<int> st;
    int j = 0; // 指向 popSeq 当前要匹配的下标

    for (int x : pushSeq) {
        st.push(x); // 模拟入栈
        // 如果栈顶等于出栈序列的当前值，就不断出栈
        while (!st.empty() && st.top() == popSeq[j]) {
            st.pop();
            j++;
        }
    }

    // 如果出栈序列全部匹配完了，则合法
    return st.empty();
}
```

### 中缀表达式转后缀表达式
中缀转后缀的基本规则如下：
- 遇到操作数，直接输出；
- 遇到左括号，入栈；
- 遇到右括号，将栈顶的运算符输出，直到遇到左括号，左括号出栈；
- 遇到运算符，将栈顶的优先级大于等于当前运算符的运算符输出，当前运算符入栈；
```cpp
// 运算符优先级函数
int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

// 判断是否为运算符
bool isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/');
}

// 中缀转后缀
string infixToPostfix(const string& expr) {
    stack<char> st;
    string output;

    for (char c : expr) {
        if (c == ' ') continue; // 忽略空格

        // 操作数
        if (isalnum(c)) {  // 字母或数字
            output += c;
            output += ' ';
        }
        // 左括号
        else if (c == '(') {
            st.push(c);
        }
        // 右括号
        else if (c == ')') {
            while (!st.empty() && st.top() != '(') {
                output += st.top();
                output += ' ';
                st.pop();
            }
            st.pop(); // 弹出 '('
        }
        // 运算符
        else if (isOperator(c)) {
            while (!st.empty() && precedence(st.top()) >= precedence(c)) {
                output += st.top();
                output += ' ';
                st.pop();
            }
            st.push(c);
        }
    }

    // 弹出栈中剩余运算符
    while (!st.empty()) {
        output += st.top();
        output += ' ';
        st.pop();
    }

    return output;
}
```

## 队列

### 队列的基本概念

1. 队列是一种**先进先出**（FIFO）的数据结构。
2. 队列的头部是允许删除的一端，队列的尾部是允许插入的一端。

### 循环队列
循环队列解决了队列的假溢出问题。
一般情况下，牺牲一个单元来区分队列是空的还是满的，约定用front指向**队头**，rear指向**队尾的下一个位置**。
> 当队列为空时：front == rear
> 当队列满时：(rear + 1) % capacity == front
> 队列中的元素个数：(rear - front + capacity) % capacity

还有两种方式区分队列是空还是满的：增设size数据成员或者设置一个标志位flag。

### 动态维护队列中的最大元素

**用一个双端单调队列来记录当前队列中的最小值**

我们维护两个队列：

1. queue：主队列（存放所有元素）
2. min_queue：辅助队列（同步记录当前队列中最小值）

#### 入队时
*   令元素进入主队列
*   如果一直有 辅助队列不为空 且 辅助队尾小于该元素，则辅助队尾出队
*   将该元素加入到辅助队尾

#### 出队时
*   如果主队首 == 辅助队首，辅助队首也要出队（因为最小值被移除了）

#### 取最小值时
*   直接返回辅助队首即可

```cpp
class MaxQueue {
public:
    queue<int> q;
    deque<int> dq;

    MaxQueue() {}

    int max_value() {
        if (dq.empty()) return -1;
        return dq.front();
    }

    void push_back(int value) {
        q.push(value);
        while (!dq.empty() && dq.back() < value) {
            dq.pop_back();
        }
        dq.push_back(value);
    }

    int pop_front() {
        if (q.empty()) return -1;
        int front = q.front();
        if (front == dq.front()) {
            dq.pop_front();
        }
        q.pop();
        return front;
    }
};
```

## 串

### 字符串模式匹配

课内讲的next数组和pi数组的关系：**next[i+1] = pi[i]+1**，即pi数组整体右移一位，然后加1。
在选择题中，是否加1都可以，加1则第一项为0，不加1则第一项为-1。

<img src="./images/data-structure/kmp.png" width="500" height="300" />

```cpp
vector<int> getPi(const string& str) {
    int n = str.size();
    vector<int> pi(n, 0);
    int len = 0;
    for (int i = 1; i < n; i++) {
        len = pi[i-1];
        while (len != 0 && str[i] != str[len]) {
            len = pi[len-1];
        }
        if (str[i] == str[len]) pi[i] = len + 1;
    }
    return pi;
}
 
int kmp(const string& s, const string& t, vector<int>& pi) {
    int n = s.size();
    vector<int> match(n, 0);
    int len = 0;
    if (s[0] == t[0]) match[0] = 1;
    for (int i = 1; i < n; i++) {
        len = match[i-1];
        while (len != 0 && s[i] != t[len]) {
            len = pi[len-1];
        }
        if (s[i] == t[len]) match[i] = len + 1;
        if (match[i] == t.size()) return i - t.size() + 1;
    }
    return -1;
}
```

# 非线性部分

## 树与二叉树

### 树的基本概念

1. 节点的层次从根开始定义，根为第一层，根的子节点为第二层，以此类推。节点的**深度**为其所在层次数，树的**高度**为所有节点深度的最大值。节点的高度是以该节点为根的子树的高度。
2. 树的**度**为树中节点的最大度数。
3. 树的路径长度是从树根到每个节点路径长度的总和。

### 二叉树的概念
1. 二叉树是有序树，若将其左右子树互换，则得到不同的二叉树。
2. 非空二叉树的叶节点树等于度为2的节点数加1，即$n_0=n_2+1$，证明略。

### 二叉树的遍历

用**递归**实现二叉树的遍历非常简单，这里不再赘述，重点介绍**迭代**实现二叉树的遍历。

以**中序遍历**为例：

迭代的核心思想是**采用栈模拟递归**。对于任意一棵树，都将其抽象为 (左子树，中节点，右子树)，也可以简称为**左-中-右**三个 "节点"。

遍历一棵树时，按照递归的思路理解，分为 进入 和 回溯 两个阶段，用栈模拟可以理解为 "**两次入栈**"：

*   第一次入栈时是以当前节点为根节点的 **整棵子树入栈**；
*   第二次入栈代表**展开**，当前节点仅代表当前节点，不再代表整棵子树；
  
两次入栈就同样对应着两次出栈：

*   第一次出栈是展开前将代表子树的栈顶节点出栈；
*   第二次出栈是展开后栈顶的**中节点**加入遍历序列；

具体地说，采用变量 flag 标记节点两次入栈的过程，flag = 0 代表第一次入栈，flag = 1 代表第二次入栈。首先根节点标记为 0 入栈，迭代取出栈顶节点时：

*   当栈顶节点的 flag = 0 时，代表子树递归进入的过程，先将栈顶节点出栈，然后按照 右子树-中节点-左子树 的顺序将该子树展开入栈，其中右子树和左子树标记为 0，中节点标记为 1
*   当 flag = 1 时，代表递归回溯的过程，将栈顶节点加入到中序遍历序列

```cpp
	vector<int> inorderTraversal(TreeNode* root) {
        
        stack<pair<TreeNode*,bool>> ms;
        vector<int> ans;
        if (!root) return ans;
        ms.push({root, false});

        while (!ms.empty()) {
            auto tp = ms.top();
            ms.pop();
            if (!tp.first) continue;
            if (tp.second) {
                ans.push_back(tp.first->val);
            } else {
				// 只需调整这里的入栈顺序即可
                ms.push({tp.first->right, false});  // 右
                ms.push({tp.first, true});  // 根
                ms.push({tp.first->left, false});  // 左
            }
        }

        return ans;
    }
```

### 由遍历序列构造二叉树

#### 前序+中序
前序序列的第一个元素是根节点，在中序序列中找到该元素，则该元素左边的元素是左子树，右边的元素是右子树，递归构造左右子树。

```cpp
template<typename T>
struct Node {
    T val;
    int len;
    Node<T>* left;
    Node<T>* right;
    Node(T x) : val(x), left(nullptr), right(nullptr) {}
};

template<typename T>
class TreeBuild {
public:

    unordered_map<T, int> index_map;

    Node<T>* buildHelper(vector<T>& preorder, vector<T>& inorder, int preleft, int preright, int inleft, int inright) 
    {
        if (preleft > preright) return nullptr;
        T rootval = preorder[preleft];
        Node<T>* root = new Node<T>(rootval);

        int rootIndex = index_map[rootval];
        int leftSize = rootIndex - inleft;

        root->left = buildHelper(preorder, inorder, preleft+1, preleft+leftSize, inleft, rootIndex-1);

        root->right = buildHelper(preorder, inorder, preleft+leftSize+1, preright, rootIndex+1, inright);

        return root;
    }

    Node<T>* build(vector<T>& preorder, vector<T>& inorder) {
        int n = preorder.size();
        for (int i = 0; i < n; i++) {
            index_map[inorder[i]] = i;
        }
        return buildHelper(preorder, inorder, 0, n-1, 0, n-1);
    }
};
```

### 线索二叉树

这里以中序线索二叉树为例，其他线索二叉树类似。
> 建立中序线索二叉树的过程就是进行一次中序遍历的过程，在中序遍历的过程中，记录**前一个节点**和当前节点。如果当前节点没有左孩子，则将当前节点的左指针指向前一个节点；如果前一个节点没有右孩子，则将前一个节点的右指针指向当前节点。

> 使用中序线索二叉树进行中序遍历，主要是寻找当前节点后继节点。如果当前节点的右标记为1，则右指针指向其后继节点；如果右标记为0，则后继节点是**其右子树中最左下方**的节点。

```cpp

ThreadedTreeNode* prev = nullptr;

ThreadedTreeNode* threaded(ThreadedTreeNode* root) {
    if (!root) return nullptr;
    threaded(root->left);
    if (prev && !root->left) {
        root->left = prev;
        root->ltag = 1;
    }
    if (prev && !prev->right) {
        prev->right = root;
        prev->rtag = 1;
    }
    prev = root;
    threaded(root->right);
    return root;
}

vector<int> inorderTraversal(ThreadedTreeNode* root) {
    vector<int> ans;
    if (!root) return ans;
    ThreadedTreeNode* now = root;
    while (now->left) {
        now = now->left;
    }
    while (now) {
        ans.push_back(now->val);
        if (now->rtag == 1) {
            now = now->right;
        } else {
            now = now->right;
            while (now && now->ltag == 0 && now->left) {
                now = now->left;
            }
        }
    }
    return ans;
}

```

### 树和森林的遍历

#### 树的遍历

树的遍历有两种方式：先根遍历、后根遍历。

#### 森林的遍历

森林的遍历有两种方式：先序遍历和中序（后序）遍历。

### 并查集

核心思路：以一个节点作为代表，来代表它所属的集合。

```cpp
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;
    int count;  // 记录连通分量数量
    
public:
    UnionFind(int n) : count(n) {
        parent.resize(n);
        rank.resize(n, 0);
        for(int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        if(parent[x] != x) {
			// 路径压缩
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    // 返回是否成功合并（原本不在同一个集合）
    bool unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if(rootX == rootY) {
            return false;  // 已经在同一个集合
        }
        
        // 按秩合并
        if(rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if(rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        
        count--;  // 合并后连通分量减少
        return true;
    }
    
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
    
    int getCount() const {
        return count;
    }
};
```


## 图

### 图的基本概念

由于图的基本概念比较简单，对于大多数内容，这里不再赘述，只简要列出需要掌握的概念，并着重强调一些易混淆的知识点。

以下是基本概念列表：图的定义（顶点集、边集）、有向图、无向图、简单图和多重图、完全图、子图、连通图和连通分量、强连通图和强连通分量、生成树和生成森林、顶点的度、入度和出度、边的权、网、稠密图和稀疏图、路径和路径长度、简单路径和简单回路、有向树

> Tips1：如果一个图满足：不存在重复边，且顶点之间没有自环，则该图是**简单图**。

> Tips2：如果一个图的任意两个顶点之间都存在边，则该图是**完全图**。无向完全图有n(n-1)/2条边，有向完全图有n(n-1)条边。

> Tips3：强连通是针对**有向**图而言的，若有一对顶点满足：a->b且b->a（**存在路径，不要求直接相连**），则这对顶点是强连通的。若图中任意一对顶点都是强连通的，则该图是**强连通图**。有向图中的极大强连通子图称为该有向图的强连通分量。

> Tips4：若有向图中存在一个顶点的入度为0，且其余顶点的入度均为1，则该图称为**有向树**。

> Tips5：区别极大和极小连通子图。**极大连通子图（连通分量）** 要求子图连通且包含尽可能多的顶点和边；**极小连通子图**要求子图连通且包含尽可能少的边。

<br>

### 图的存储

#### 邻接矩阵
邻接矩阵的存储结构是一个二维数组，行和列的索引分别表示顶点，数组元素表示两个顶点之间是否存在边。
对于有向图，统计**某一行或某一列的元素为1的个数**，即为该顶点的入度或出度。无向图同理，但不区分入度和出度。
稠密图适合用邻接矩阵存储，稀疏图适合用邻接表存储。

#### 邻接表
邻接表存储结构是一个链表数组，数组的索引表示顶点，链表数组的元素是一个链表，链表的元素表示该顶点所连接的顶点。

> Tips1：一个图的邻接矩阵表示唯一，邻接表表示**不唯一**。

> Tips2：有向图的邻接表中，默认链表中的元素是弧尾。

#### 十字链表
十字链表是一种**用于存储有向图**的链式数据结构，它将邻接矩阵的行和列分别存储为两个链表，分别表示顶点的入度和出度。

#### 邻接多重表
邻接多重表是一种**用于存储无向图**的链式数据结构，它将邻接矩阵的行和列分别存储为两个链表。

<br>

### 图的遍历

#### 复杂度分析
遍历算法的复杂度取决于采用的存储结构。
如果采用邻接表存储结构，每个节点需要访问一次，在搜索每个节点的邻接点时，需要遍历该节点的链表，因此时间复杂度为O(|V|+|E|)。
如果采用邻接矩阵存储结构，每个节点需要访问一次，在搜索每个节点的邻接点时，需要遍历该行或列，因此时间复杂度为O(|V|²)。

#### BFS
唯一需要注意的是，在入队时就将顶点标记为已访问，避免重复入队。而不是等到出队访问时才进行标记。

#### DFS

> Tips1：对同一个图，基于邻接矩阵遍历得到的DFS和BFS序列是唯一的，但邻接表遍历得到的DFS和BFS序列**不唯一**。

<br>

### 图的应用

#### 最小生成树
一个连通图的生成树包含图的所有顶点，并且只包含构成连通图的最少的边。对于一个带权连通无向图G，生成树不同，每棵树的权值也可能不同，权值之和最小的那棵生成树称为G的**最小生成树**。

##### Prim算法
Prim算法是一种贪心算法，用于求解最小生成树。其基本思想是从一个顶点开始，逐步将顶点加入生成树，每次**选择一个与当前生成树距离最近的顶点加入生成树**，直到所有顶点都被加入生成树。

##### Kruskal算法
Kruskal算法也是一种贪心算法，用于求解最小生成树。其基本思想是将所有边按权值从小到大排序，然后**依次选择权值最小的边加入生成树**，但需要判断加入该边后是否会形成环（使用并查集判断该边的两个顶点是否已经连通），如果会形成环，则不加入该边。

#### 最短路径
最短路径是指从一个顶点到另一个顶点的最短路径，对于带权图，最短路径的权值之和最小。对于无权图，最短路径的边数最少。

##### Dijkstra算法
Dijkstra算法是一种贪心算法，用于求解**非负**权图的**单源**最短路径。
> 假设有n个顶点，求解顶点1到其余各个顶点的最短路径。
> 维护3个数组：dist[]表示顶点1到其余顶点的最短路径长度，prev[]表示最短路径的前驱顶点，flag[]表示顶点是否已经确定最短路径（是否已经加入集合S）。
> 1. 初始化：将顶点1加入集合S，表示已经访问过的顶点，其余顶点加入集合U，表示未访问过的顶点。初始化距离数组dist，将顶点1到其余顶点的距离设为无穷大，将顶点1到自身的距离设为0。
> 2. 选择：在集合U中，选择一个dist值最小的顶点v，将其加入集合S，即令flag[v] = true。
> 3. 更新：对于v的每个邻居节点k，若dist[v] + weight(v, k) < dist[k]，则更新**dist[k] = dist[v] + weight(v, k)**，并更新**prev[k] = v**。
> 4. 重复步骤2和步骤3，直到集合U为空。
>
> 堆优化：使用最小堆来维护集合U中的顶点，每次选择dist值最小的顶点，堆操作的时间复杂度为O(log|V|)。

##### Floyd算法
Floyd算法是一种动态规划算法，用于求解**任意两点之间**的最短路径。其基本思想是逐步增加路径的中间顶点，更新最短路径。

> 假设有n个顶点，求解任意两点之间的最短路径。
> 维护一个二维数组dist，dist[i][j]表示顶点i到顶点j的最短路径长度。
> 1. 初始化：将dist数组初始化为邻接矩阵，将dist[i][i]设为0，其余元素设为无穷大。
> 2. 更新：对于每个中间顶点k（k从1遍历到n），更新**dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])**。
> 3. 返回dist数组。
>
> 注意：Floyd算法适用于带负权值的图，但不适用于带负权回路的图。

#### 拓扑排序
拓扑排序是指将一个有向无环图（DAG）中的顶点按照顶点之间的依赖关系排序，使得对于每一条有向边(u, v)，顶点u在顶点v之前出现。
AOV网（Activity On Vertex Network）是一种特殊的**有向无环图**，用于表示工程中的各个活动及其相互关系。AOV网中的顶点表示活动，边表示活动之间的依赖关系。
> 拓扑排序的算法：
> 1. 统计每个顶点的入度，将入度为0的顶点加入队列。
> 2. 从队列中取出一个顶点，将其加入拓扑排序序列，并将其所有邻接点的入度减1，如果某个邻接点的入度减为0，则将其加入队列。
> 3. 重复步骤2，直到队列为空。

#### 关键路径
AOE网（Activity On Edge Network）是一种特殊的**有向无环图**，用于表示工程中的各个活动及其相互关系。AOE网中的顶点表示事件，边表示活动，边的权值表示活动的持续时间。**关键路径**是指从源点到汇点的最长路径，即路径上的活动持续时间之和最大的路径。

